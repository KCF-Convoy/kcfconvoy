# Basic Usage of KCF Convoy
- As a basic import, import the following things

```python
from IPython.display import Image
%matplotlib inline
import kcfconvoy as kcf
```

- Basic classes include the following
    - KCFvec (KCF vector)
    - KCFmat (KCF matrix)

## KCFvec (KCF vector)
- There are the following as input form
    - KEGG ID https://www.kegg.jp
    - KNApSAcK ID http://kanaya.naist.jp/KNApSAcK/
    - Molfile
    - InChI
    - RDKmol
- As the class method, the following correspond to each other
    - `input_from_kegg(cid, cpd_name=str)`
        - Download from KEGG_ID in mol format and save it as `./Kegg/cid.mol`
    - `input_from_knapsack(cid, cpd_name=str)`
        - Download from knapsack_ID in mol format and save it as `./knapsack/cid.mol`
    - `input_molfile(molfile, cpd_name=str)`
        - It accepts the path of molfile, not the entity of molfile.
    - `input_inchi(inchi, cpd_name=str)`
    - `input_smiles(smiles, cpd_name=str)`
    - `input_rdkmol(rdkmol, cpd_name=str)`

```python
kcfvec_1 = kcf.KCFvec()
kcfvec_1.input_smiles('Oc1cnc(CO)cc1')
kcfvec_2 = kcf.KCFvec()
kcfvec_2.input_from_kegg('C00002', "ATP")
```

---

- The instance variables of KCFvec are listed below
    - `n_atoms`
        - Number of atoms in a compound
    - `n_bonds`
        - Number of edges in a compound
    - `mol`
        - RDKmol generated by RDKit
    - `cpd_name`
        - Name of compound
    - `kegg_atom_label`
        - The labels for KCF generated from RDKmol
    - `molblock_atoms`
        - The atom blocks in the Molfile format
    - `molblock_bonds`
        - The bond blocks in the Molfile format
    - `kcf_vec`
        - KCF Vector
    - `ring_string`
        - The strings that represent the ring substructures and their atom IDs.
    - `subs_string`
        - The strings that represent the other substructures and their atom IDs.

```python
print(kcfvec_1.n_atoms)
print(kcfvec_1.n_bonds)
print(kcfvec_1.mol)
print(kcfvec_1.cpd_name)
print(kcfvec_1.kegg_atom_label)
print(kcfvec_1.molblock_atoms)
print(kcfvec_1.molblock_bonds)

9
9
<rdkit.Chem.rdchem.Mol object at 0x7fee16d00940>
NoName
{0: {'atom_species': 'O', 'atom_class': 'O1', 'kegg_atom': 'O1a'}, 1: {'atom_species': 'C', 'atom_class': 'C8', 'kegg_atom': 'C8y'}, 2: {'atom_species': 'C', 'atom_class': 'C8', 'kegg_atom': 'C8x'}, 3: {'atom_species': 'N', 'atom_class': 'N5', 'kegg_atom': 'N5x'}, 4: {'atom_species': 'C', 'atom_class': 'C8', 'kegg_atom': 'C8y'}, 5: {'atom_species': 'C', 'atom_class': 'C1', 'kegg_atom': 'C1b'}, 6: {'atom_species': 'O', 'atom_class': 'O1', 'kegg_atom': 'O1a'}, 7: {'atom_species': 'C', 'atom_class': 'C8', 'kegg_atom': 'C8x'}, 8: {'atom_species': 'C', 'atom_class': 'C8', 'kegg_atom': 'C8x'}}
{0: ['3.0000', '0.0000', '0.0000'], 1: ['1.5000', '0.0000', '0.0000'], 2: ['0.7500', '-1.2990', '0.0000'], 3: ['-0.7500', '-1.2990', '0.0000'], 4: ['-1.5000', '0.0000', '0.0000'], 5: ['-3.0000', '0.0000', '0.0000'], 6: ['-3.7500', '1.2990', '0.0000'], 7: ['-0.7500', '1.2990', '0.0000'], 8: ['0.7500', '1.2990', '0.0000']}
[['1', '2', '1', '0'], ['2', '3', '2', '0'], ['3', '4', '1', '0'], ['4', '5', '2', '0'], ['5', '6', '1', '0'], ['6', '7', '1', '0'], ['5', '8', '1', '0'], ['8', '9', '2', '0'], ['9', '2', '1', '0']]
```

---

- In order to generate KCF vectors, it is necessary to execute the following method
    - `convert_kcf_vec(levels=int_list, attributes=int_list)`
        - `levels`
            - the levels of the three-letter KEGG Atom types. e.g., "C1a" means a methyl carbon (i.e., an sp3 carbon that locates at the terminal). In this case, levels=[0] yields "C", levels=[0,1] yields "C1", and levels=[0,1,2] yields "C1a". See https://www.genome.jp/kegg/reaction/KCF.html for the list of KEGG Atome types. In default, levels is set to [0,1,2]
        - `attributes`
            - the attributes of the chemical substctures. e.g., 0: atom, 1: bond, 2: triplet, 3: vicinity, 4: ring, 5: other attributes of substructures. If the users want to use atom, bond and triplet, set attrbutes=[0,1,2]. In default, attributes is set to [0, 1, 2, 3, 4, 5]. See https://bmcsystbiol.biomedcentral.com/articles/10.1186/1752-0509-7-S6-S2 for more detail.

```python
print(kcfvec_1.kcf) # output as a KCF format file

ENTRY       NoName                        Compound
ATOM        9    
            1   O1a O    3.0000   0.0000  
            2   C8y C    1.5000   0.0000  
            3   C8x C    0.7500   -1.2990 
            4   N5x N    -0.7500  -1.2990 
            5   C8y C    -1.5000  0.0000  
            6   C1b C    -3.0000  0.0000  
            7   O1a O    -3.7500  1.2990  
            8   C8x C    -0.7500  1.2990  
            9   C8x C    0.7500   1.2990  
BOND        9    
            1     1   2 1
            2     2   3 2
            3     3   4 1
            4     4   5 2
            5     5   6 1
            6     6   7 1
            7     5   8 1
            8     8   9 2
            9     9   2 1
///
```

```python
print(kcfvec_1.ring_string) #  The strings that represent the ring substructures and their atom IDs.

[{'1,2,3,4,7,8': 'C-C-C-C-C-N,1-6'}, {'1,2,3,4,7,8': 'C8-C8-C8-C8-C8-N5,1-6'}, {'1,2,3,4,7,8': 'C8x-C8x-C8y-C8x-N5x-C8y,1-6'}]
```

```python
print(kcfvec_1.subs_string) #  The strings that represent the other substructures and their atom IDs.

[{'1,2': 'C-C', '1,4,5,7,8': 'C-C-C-C-C', '1,4,7,8': 'C-C-C-C', '1,7,8': 'C-C-C', '1,8': 'C-C', '1,2,4,5,7,8': 'C-C-C-C-C-C', ...
```

### Depiction
- As a method for drawing, there are the following:
    - `draw_cpd(image_file=file_name)`
        - Drawing of compounds
        - Save it in the execution directory with the name of image_file
    - `draw_cpd_with_labels(start=0, custom_label=dict)`
        - Drawing of labeled compounds

### Other methods
- Other methods have the following
    - `find_seq(length, bidirectonal=bool)`
        - returns the list of atom IDs whose lengths equals or less than the defined length. "bidirectonal" determines if the molecular graph is dealt as a bidirectional graph or not.
    - `has_bond(atom_1, atom_2)`
        - True if atom_1 and atom_2 are connected. False otherwise.
    - `get_symbol(atom_index)`
        - returns the symbol of atomic element (e.g., "C" for a cabon atom) for the specified atom by atom_index
    - `get_triplets()`
        - returns the list of atom IDs that consists of triplet substructures
    - `get_vicinities()`
        - returns the list of atom IDs that consists of vicinity substructures
    - `get_pandas_df()`
        - returns the KCF vector as a Pandas Dataframe
    - `string2seq()`
        - returns a dictionary in which the keys are the substructure string and the values are the corresponding list of atom IDs.

## KCFmat (KCF matrix)
- A set of KCF vectors dealing with more than two compounds
- There are the following as input form
    - KEGG ID https://www.kegg.jp
    - KNApSAcK ID http://kanaya.naist.jp/KNApSAcK/
    - Molfile
    - InChI
    - RDKmol
- As the class method, the following correspond to each other
    - `input_from_kegg(cid, cpd_name=str)`
        - Download from KEGG_ID in mol format and save it as `./Kegg/cid.mol`
    - `input_from_knapsack(cid, cpd_name=str)`
        - Download from knapsack_ID in mol format and save it as `./knapsack/cid.mol`
    - `input_molfile(molfile, cpd_name=str)`
        - It accepts the path of molfile, not the entity of molfile.
    - `input_inchi(inchi, cpd_name=str)`
    - `input_smiles(smiles, cpd_name=str)`
    - `input_rdkmol(rdkmol, cpd_name=str)`

```
kcfmat = kcf.KCFmat()
kcfmat.input_from_kegg('C00002', "ATP")
kcfmat.input_from_kegg('C00003', "NAD+")
kcfmat.input_from_kegg('C00004', "NADH")
kcfmat.input_from_kegg('C00005', "NADPH")
kcfmat.input_from_kegg('C00006', "NADP+")
kcfmat.input_from_kegg('C00008', "ADP")
```

- When the users input the compounds into KCFmat, the following member variables are calculated automatically.
    - `inchis`
        - list of InChI strings for the compounds
    - `names`
        - list of names for the compounds 
    - `kcf_vecs`
        - list of KCF vectors for the compounds
    - `all_strs`
        - list of all the substructure strings within the KCF vector

```python
print(kcfmat.inchis[0])

InChI=1S/C10H16N5O13P3/c11-8-5-9(13-2-12-8)15(3-14-5)10-7(17)6(16)4(26-10)1-25-30(21,22)28-31(23,24)27-29(18,19)20/h2-4,6-7,10,16-17H,1H2,(H,21,22)(H,23,24)(H2,11,12,13)(H2,18,19,20)

print(kcfmat.names)

['ATP', 'NAD+', 'NADH', 'NADPH', 'NADP+', 'ADP']
```

---

- `calc_kcf_matrix(ratio=400)`
    - The users need to run this method in order to obtain the KCF matrix in the Numpy array format.
    - `all_mat` contains all substructures, which may contain the substructures found in only few compounds. len(`all_mat`) corresponds to the number of compounds.
    - `mat` contains limited substuctures for which the frequency (occurrence) values are more than len(`all_mat`) / `ratio` .
    - `mask_array` represents whether or not `mat` contains the substructure in `all_mat` .

### Similarity measures between two KCF vectors
`similarity` calculates similarity between two KCF vectors     
- similarity(kcf_vec_1, kcf_vec_2, n_nodes=list(range(100)), levels=[0, 1, 2])
    - kcf_vec_1, kcf_vec_2
        - KCF vectors of compounds 1 and 2, respectively.
    - `n_nodes`
        - specifies the size range of substructures by the numbers of nodes (atoms other than hydrogen atoms). In default, `n_nodes` is set to list(range(100)), meaning that the users consider the substructures ranging from 0 - 99 in size.
    - `levels`
         - the levels of the three-letter KEGG Atom types. e.g., "C1a" means a methyl carbon (i.e., an sp3 carbon that locates at the terminal). In this case, levels=[0] yields "C", levels=[0,1] yields "C1", and levels=[0,1,2] yields "C1a". See https://www.genome.jp/kegg/reaction/KCF.html for the list of KEGG Atome types. In default, `levels` is set to [0,1,2]
- The output consists of the following three numerals in a tuple:
    - The first numeral represents the weighted tanimoto similarity.
    - The second numeral represents the ratio of conserved substructures from compound 1 in compound 2.
    - The third numeral represents the ratio of conserved substructures from compound 2 in compound 1.

```python
from kcfconvoy import similarity
similarity(kcfvec_1, kcfvec_2)

(0.03381995133819951, 0.3926553672316384, 0.035686777920410785)

similarity(kcfmat.kcf_vecs[1], kcfmat.kcf_vecs[2])

(0.6641890098221397, 0.7974501992031873, 0.7989781254989622)
```

### Calculating fingerprints implemented in RDKit
- The following fingerprints implemented in RDKit can also be calculated and incorporated easily into KCF matrix.
    - RDKFingerprint
    - PatternFingerprint
    - MorganFingerprint
    - LayeredFingerprint
    - PatternFingerprint
- By using `fingerprint` argument, the users can select the fingerprint. The calculated fingerprints are stored in `KCFmat.fps`

```python
kcfmat.calc_fingerprints(fingerprint="MorganFingerprint")
print(kcfmat.fps)

[<rdkit.DataStructs.cDataStructs.ExplicitBitVect object at 0x7fd5eebd24e0>, <rdkit.DataStructs.cDataStructs.ExplicitBitVect object at 0x7fd5ef029d00>, <rdkit.DataStructs.cDataStructs.ExplicitBitVect object at 0x7fd5ef029260>, <rdkit.DataStructs.cDataStructs.ExplicitBitVect object at 0x7fd5ef029cb0>, <rdkit.DataStructs.cDataStructs.ExplicitBitVect object at 0x7fd5ef029760>, <rdkit.DataStructs.cDataStructs.ExplicitBitVect object at 0x7fd5ef029bc0>]
```